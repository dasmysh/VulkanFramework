#version 460
#extension GL_EXT_ray_tracing : require

#include "ray.glsl"
#include "../core/random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT RayPayload hitValue;

const float PI = 3.14159265359;
const float aoRayCount = 64;

vec3 randomPointOnHemisphere(vec3 seed) {
    vec2 p = vec2(0.0f);
    vec2 u = vec2(random(seed), random(vec3(seed.xy, seed.z + 0.5f / float(aoRayCount))));
    vec2 uOffset = 2.0f * u - vec2(1.0f);

    if (uOffset.x != 0 || uOffset.y != 0) {
        float theta, r;
        if (abs(uOffset.x) > abs(uOffset.y)) {
            r = uOffset.x;
            theta = (PI / 4.0f) * (uOffset.y / uOffset.x);
        } else {
            r = uOffset.y;
            theta = (PI / 2.0f) - (PI / 4.0f) * (uOffset.x / uOffset.y);
        }
        p = r * vec2(cos(theta), sin(theta));
    }

    float z = sqrt(max(0.0f, 1.0f - p.x * p.x - p.y * p.y));
    return vec3(p.x, p.y, z);
}

float pdfPointOnHemisphere(float cosTheta) {
    return cosTheta / PI;
}

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = cam.viewInverse * vec4(0,0,0,1);
    vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
    vec4 direction = cam.viewInverse*vec4(normalize(target.xyz / target.w), 0) ;

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    hitValue.attenuation = vec3(1.0f);
    hitValue.rayDirection = direction.xyz;
    hitValue.rayOrigin = origin.xyz;
    hitValue.done = 0;

    traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, hitValue.rayOrigin, tmin, hitValue.rayDirection, tmax, 0);

    vec3 resultColor = hitValue.attenuation;
    if (hitValue.done == 0) {
        vec3 ao = vec3(0.0f);
        vec3 seed = vec3(inUV, 0.0f);
        for (int i = 0; i < int(aoRayCount); ++i) {
            vec3 aoOrigin = hitValue.rayOrigin;
            vec3 normal = hitValue.rayDirection;

            vec3 rightDir = vec3(0.0f, 1.0f, 0.0f);
            if (normal.x < normal.y) {
                vec3 rightDir = vec3(1.0f, 0.0f, 0.0f);
            }

            vec3 forwardDir = normalize(cross(normal, rightDir));
            rightDir = normalize(cross(forwardDir, normal));
            vec3 randDir = randomPointOnHemisphere(seed);
            seed.z += 1.0f / float(aoRayCount);
            float randPdf = pdfPointOnHemisphere(abs(randDir.z));
            vec3 aoDirection = normalize(randDir.x * rightDir + randDir.y * forwardDir + randDir.z * normal);

            traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, aoOrigin, tmin, aoDirection, tmax, 0);
            if (hitValue.attenuation.x > 0.001f) {
                ao += dot(aoDirection, normal) / (randPdf * aoRayCount);
            }
        }
        resultColor = ao;
    }

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(resultColor, 0.0));
}
