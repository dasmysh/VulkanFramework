#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#define RAYGEN

#include "../../core/random.glsl"
#include "../../core/sampling.glsl"
#include "../rayTraversal.glsl"
#include "path_host_interface.h"

layout(binding = AccelerationStructure, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = ResultImage, set = ConvergenceSet, rgba32f) uniform image2D image;

// start material callable interface
struct MaterialCallableParameters
{
    // - vec3 barycentrics -> new position
    vec3 inBarycentricsOutPosition;
    uint rngState;
    // - ivec3 instanceId + primitiveId + dummy -> L
    ivec3 inInstancePrimitiveIdsOutL;
    // - bool addEmissive -> isSpecularBRDF
    bool inAddEmissiveOutIsSpecularBRDF;
    vec3 beta;
    vec3 w;
};

#ifdef DISPATCH_MATERIAL
layout(location = 0) callableDataEXT MaterialCallableParameters materialCallableParams;
#else
// layout(location = 0) callableDataInEXT MaterialCallableParameters materialCallableParams;
#endif

// end material callable interface

// start pbrt helper
bool IsBlack(vec3 color)
{
    return max(color.x, max(color.y, color.z)) <= 0.0f;
}

float AbsDot(vec3 u, vec3 v)
{
    return abs(dot(u, v));
}

vec3 face_forward(vec3 direction, vec3 normal)
{
    if (dot(normal, direction) > 0.0f) normal *= -1;
    return normal;
}

void compute_default_basis(const vec3 normal, out vec3 tangent, out vec3 binormal)
{
  if(abs(normal.x) > abs(normal.y))
    tangent = vec3(normal.z, 0, -normal.x) / sqrt(normal.x * normal.x + normal.z * normal.z);
  else
    tangent = vec3(0, -normal.z, normal.y) / sqrt(normal.y * normal.y + normal.z * normal.z);
  binormal = cross(normal, tangent);
}
// end pbrt

// start mirror
bool isSpecular()
{
    return true;
}

vec3 material_brdf()
{
    return vec3(0);
}

float material_pdf()
{
    return 0;
}
// end mirror

vec3 estimate_single_light(vec3 origin, vec3 shadingNormal, vec3 wo)
{
    const vec3 light_position = vec3(0.0f, 2.0f, 0.0f);
    const vec3 I = vec3(0.9882f, 0.0588f, 0.7529f);

    vec3 Ld = vec3(0.0f);

    // start point light sample_li; out: lightPdf, wi, Li
    float lightPdf = 1.0f;
    vec3 d = light_position - origin;
    vec3 wi = normalize(d);
    vec3 Li = I / dot(d, d);
    // end point light sample_li

    if (lightPdf > 0 && !IsBlack(Li)) {
        // only surface interactions for now.

        // Evaluate BSDF for light sampling strategy
        const SurfaceInteraction &isect = (const SurfaceInteraction &)it;
        f = isect.bsdf->f(isect.wo, wi, bsdfFlags) * AbsDot(wi, shadingNormal);

        if (!IsBlack(f)) {
            bool hit = queryShadowRayHit(origin, d, topLevelAS, 1.0f);

            // Compute effect of visibility for light source sample
            if (hit) {
                Li = vec3(0.f);
            }

            // Add light's contribution to reflected radiance
            if (!IsBlack(Li)) {
                Ld += f * Li / lightPdf;
            }
        }
    }

    return Ld;

    *wi = Normalize(pLight - ref.p);
    *pdf = 1.f;
    *vis =
        VisibilityTester(ref, Interaction(pLight, ref.time, mediumInterface));
    return I / DistanceSquared(pLight, ref.p);




    BxDFType bsdfFlags = BxDFType(BSDF_ALL & ~BSDF_SPECULAR);


    Spectrum Ld(0.f);
    // Sample light source with multiple importance sampling
    Vector3f wi;
    Float lightPdf = 0, scatteringPdf = 0;
    VisibilityTester visibility;
    Spectrum Li = light.Sample_Li(it, uLight, &wi, &lightPdf, &visibility);



    if (lightPdf > 0 && !Li.IsBlack()) {
        // Compute BSDF or phase function's value for light sample
        Spectrum f;
        if (it.IsSurfaceInteraction()) {
            // Evaluate BSDF for light sampling strategy
            const SurfaceInteraction &isect = (const SurfaceInteraction &)it;
            f = isect.bsdf->f(isect.wo, wi, bsdfFlags) *
                AbsDot(wi, isect.shading.n);
            scatteringPdf = isect.bsdf->Pdf(isect.wo, wi, bsdfFlags);
            VLOG(2) << "  surf f*dot :" << f << ", scatteringPdf: " << scatteringPdf;
        } else {
            // Evaluate phase function for light sampling strategy
            const MediumInteraction &mi = (const MediumInteraction &)it;
            Float p = mi.phase->p(mi.wo, wi);
            f = Spectrum(p);
            scatteringPdf = p;
            VLOG(2) << "  medium p: " << p;
        }
        if (!f.IsBlack()) {
            // Compute effect of visibility for light source sample
            if (handleMedia) {
                Li *= visibility.Tr(scene, sampler);
                VLOG(2) << "  after Tr, Li: " << Li;
            } else {
              if (!visibility.Unoccluded(scene)) {
                VLOG(2) << "  shadow ray blocked";
                Li = Spectrum(0.f);
              } else
                VLOG(2) << "  shadow ray unoccluded";
            }

            // Add light's contribution to reflected radiance
            if (!Li.IsBlack()) {
                if (IsDeltaLight(light.flags))
                    Ld += f * Li / lightPdf;
                else {
                    Float weight =
                        PowerHeuristic(1, lightPdf, 1, scatteringPdf);
                    Ld += f * Li * weight / lightPdf;
                }
            }
        }
    }

    return Ld;
}

vec3 next_event_estimation(vec3 origin. vec3 shadingNormal, vec3 wo)
{
    const float lightPdf = 1.0f;

    return estimate_single_light(origin, shadingNormal) / lightPdf;
}

void main()
{
    vec4 resultColor = vec4(0.0f);
    if (frame.cameraMovedThisFrame != 1) {
        resultColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy));
    }

    uint rngState = initRNG(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, frame.frameId);

    vec3 origin, direction;
    sampleCameraRay(origin, direction, cam, rngState);

    float tmax = 10000.0;

    vec3 beta = vec3(1.0f);
    vec3 L = vec3(0.0f);
    bool specularBounce = false;

    for (int bounces = 0;; ++bounces)
    {
        vec3 barycentrics;
        int instanceId, primitiveId;
        bool foundIntersection = findNextHitIterative(origin, direction, barycentrics, instanceId, primitiveId, topLevelAS, tmax);

        bool addEmissive = bounces == 0 || specularBounce; // in all other cases emissives are accounted for in last iterations next event estimation.
        if (!foundIntersection && addEmissive)
        {
            // for (const auto &light : scene.infiniteLights)
            // {
            //     L += beta * light->Le(ray);
            // }

            // needs to be zero as long as not infinite light sources are present.
        }

        if (!foundIntersection || bounces < path.maxDepth) break;

        uint materialType = instances.i[gl_InstanceID].materialType;
        materialCallableParams.inBarycentricsOutPosition = barycentrics;
        materialCallableParams.rngState = rngState;
        materialCallableParams.inInstancePrimitiveIdsOutL.xy = ivec2(instanceId, primitiveId);
        materialCallableParams.inAddEmissiveOutIsSpecularBRDF = addEmissive;
        materialCallableParams.beta = beta;
        materialCallableParams.w = direction;
        executeCallableEXT(materialType??, 0);
        // START CALLABLE:
        vec3 barycentrics = materialCallableParams.inBarycentricsOutPosition;
        int instanceId = materialCallableParams.inInstancePrimitiveIdsOutL.x;
        int primitiveId = materialCallableParams.inInstancePrimitiveIdsOutL.y;
        vec3 wo = materialCallableParams.w;
        // in:
        // - bool addEmissive -> isSpecularBRDF
        // - vec3 barycentrics -> new position
        // - ivec3 instanceId + primitiveId + dummy -> L

        // - ivec3 instanceId + primitiveId + dummy -> L

        // = vec3 old beta (for emissive)
        // = vec3 old direction (for brdf calculation)
        // = uint rngState
        // out:
        // - vec3 L (to add to this L)
        // - vec3 new position (for next trace, only if not calculated before)
        // = vec3 beta (update value in struct)
        // = vec3 new direction (overwrite old direction)
        // = uint rngState
        // - bool isSpecularBRDF (to update specularBounce)
        if (materialCallableParams.inAddEmissiveOutIsSpecularBRDF) {
            // L += materialCallableParams.beta * isect.Le(-ray.d);
            // no emissive so far ...
        }

        // get some brdf information
        bool isSpecularBRDF = isSpecular();
        origin = ;
        vec3 shadingNormal = ; // shading normal??

        if (!isSpecularBRDF)
        {
            // next event estimation
            vec3 L = materialCallableParams.beta * next_event_estimation(origin, shadingNormal, wo);
            materialCallableParams.inInstancePrimitiveIdsOutL.rgb = floatBitsToInt(L);
        }


        // sample brdf
        direction = ;
        float pdf = ;
        vec3 f = ;


        if (IsBlack(f) || pdf == 0.f) {
            materialCallableParams.beta = vec3(0.0f);
            return;
        }

        materialCallableParams.beta *= f * AbsDot(wi, shadingNormal) / pdf;
        materialCallableParams.inBarycentricsOutPosition = origin;
        materialCallableParams.inAddEmissiveOutIsSpecularBRDF = isSpecularBRDF;
        materialCallableParams.w = wo;
        // END CALLABLE

        beta = materialCallableParams.beta;
        if (IsBlack(beta)) break;

        L += intBitsToFloat(materialCallableParams.inInstancePrimitiveIdsOutL.rgb);
        origin = materialCallableParams.inBarycentricsOutPosition;
        direction = materialCallableParams.w;
        rngState = materialCallableParams.rngState;
        specularBounce = materialCallableParams.inAddEmissiveOutIsSpecularBRDF;

        // ignore this for now:
        // if ((flags & BSDF_SPECULAR) && (flags & BSDF_TRANSMISSION)) {
        //     Float eta = isect.bsdf->eta;
        //     // Update the term that tracks radiance scaling for refraction
        //     // depending on whether the ray is entering or leaving the
        //     // medium.
        //     etaScale *= (Dot(wo, isect.n) > 0) ? (eta * eta) : 1 / (eta * eta);
        // }

        // russian roulette
        float rr = max(beta.r, max(beta.g, beta.b));
        if (rr < path.rrThreshold && bounces > 3)
        {
            float q = max(0.05f, 1.0f - rr);
            if (rand(rngState) < q) {
                break;
            }

            beta /= 1.0f - q;
            // DCHECK(!std::isinf(beta.y()));
        }
    }

    if (!hit) {
        resultColor = vec4(normal, 1.0f);
    }
    else
    {
        vec3 n = face_forward(direction.xyz, normal);
        vec3 s, t;
        compute_default_basis(n, s, t);
        vec3 p = origin.xyz;

        for (int i = 0; i < int(aoRayCount); ++i) {
            vec3 sample_direction;
            float pdf;
            sample_direction = sampleUniformHemisphere(n, s, t, rngState);
            pdf = uniformHemispherePDF();

            vec3 hitNormal, rayOrigin = p, rayDirection = sample_direction;
            if (!findNextNonSpecularHit(rayOrigin, rayDirection, hitNormal, topLevelAS, 10.0)) {
                resultColor += vec4(vec3(dot(sample_direction, n) / (M_PI * pdf)), 1.0f);
            }
            else
            {
                resultColor += vec4(vec3(0), 1.0f);
            }
        }
        resultColor;
    }

    resultColor += vec4(L, 1.0f);
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), resultColor);
}
